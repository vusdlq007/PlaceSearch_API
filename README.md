# 서비스 명 : Place Search Service

### 개요 : 장소 검색 서비스 구현
###
#### 주요 기능
* [기본 : 장소 검색]
* [기본 : 검색 키워드 목록]
* [추가 : 사용자 검색 활동 추적 로깅 ]
* [추가 : -필요시 개발간 추가 예정-]

## 프로젝트 개발환경
- 로컬 개발환경 OS : window 10
- 언어 / 버전 : java / 11
- 프레임워크 : Spring boot 2.7.4
- RDBMS : MariaDB 10.9.3 (127.0.0.1:13306)
- IN-MEMORY DB : Redis 7.0.5 (127.0.0.1:6379)
- Swagger 2.0 적용
- 서비스 포트 : 9802
* * *
## 주요 사용 기술 스택 & 사용목적
- **Spring AOP**
 : 추후 서비스 앞단에서 공통적으로 수행해야할 로직이 있다면 AOP 구현으로 세부적이고 간편하게 추가 기능개발 및 유지보수를 할 수 있도록 고려하여 사용.
- **Spring Data JPA** (ORM) : 같은 SQL코드의 반복 해소 및 JPA의 영속성컨텍스트안에 1차 캐쉬 변경감지 기능과 지연로딩 & 즉시로딩과 같이 상황에 따른 리소스 컨트롤이 가능하고 궁극적으로
어떤 DB가 채택되던지 간에 간편한 설정으로 연동할 수 있는 확장성을 가져갈 수 있고 개발자는 개발에만 집중할 수 있는 장점이 있어 사용.
- **Spring Data Redis** (In-memory db) : 잦은 조회건의 리소스를 RDBMS에게서 나눠 부하분산과 조회속도 이점을 얻으려 사용. 
- **Spring Webflux** : 비동기, non-blocking을 쉽고 유연하게 구현하고, 이벤트 기반의 핸들링이 가능한 Netty 프레임워크형식의 코드작성이 가능해서 특정이벤트별로 컨트롤이가능하며,
추후 Client에서 빠른응답을 받아야하고 많은데이터를 받아와야하는 Async/non-blocking 로직이 있다면 Webflux를 통해 성능 및 빠른 응답을 가져갈수 있는 이점을 가져갈수있어 사용.
~~단, 일반적인 MVC Sync-blocking 로직은 Webflux가 성능이 더 떨어지기 때문에 사용하지않는다.~~  
* * *
## 설계 내용
###[주요 설계 및 구현 방향]

- 여러 외부 API를 호출하는만큼 non-blocking 방식으로 병렬 호출하여 Client의 응답속도를 줄이도록 고려하였고, 다양한 동시성 이슈를 방지하기위해 코드상에서 내부 DB 트랜잭션 범위,레벨,전파옵션등을 고려하려 노력하였고, 코드상 스레드 세이프하도록 고려 & 구현하였습니다.
- 코드 아키텍처 구조는 기본적으로 싱글톤 디자인 패턴을 사용하고 SOLID원칙을 지키되 추후 유지보수 및 확정성을 고려하고 앞으로 개선/추가/수정될 부분을 감안하여 최대한 객체를 명확하게 구현하였습니다. (ex) 인터페이스 책임분리,DTO 상세 선언,Constants 관리 등)
- 제가 생각하는 클린코드의 기본 목적은 관심사를 분리하는 것이라 생각하여 계층간에 의존성을 낮춰 내부영역이 (프레임워크나 데이터베이스 엔티티 등) 외부요소에 의존 하지 않도록 구현하였습니다.
- @Aspect를 통해 직접 AOP 를 구현하여 키워드 조회 액션의 성공 콜백작업을 구현함으로써 중복코드 방지와 의존도를 낮추고 편리하게 공통작업을 관리 할수있도록 구현하였습니다.
- 조회수와 같은경우 동시간에 변경건이 들어올 경우도 대비하여 @Transactional 을 DB에 Create, Update, Delete 메서드 단위로 걸어 트랜잭션을 나눠 관리하여 커밋, 롤백 트랜잭션 단위를 명확하게 나눠 관리하여 동시 요청시 데이터 정합성을 고려하였습니다.
추후 유지보수 및 DBMS교체 등에 최대한 영향도가 적도록 JPA(ORM)을 사용하여 개발하였고 유지보수 측면으로 보았을땐 추후 규모가 더 커져 한 트랙잭션에서 재조회같은 경우가 발생할경우 영속성컨텍스트의 장점인 1차캐쉬를 사용하여 DB 리소스 및 처리속도를 늘릴수 있다는걸 고려하여 적용하였습니다.

###[상세 구현 설명]
###**1) 동시성 제어 및 데이터 정합성 고려**

- DB(Redis,MariaDB)에서 일어날 수 있는 **동시성 이슈**를 해결하기 위해 **@Transactional** 을 사용하여 트랜잭션 격리 수준을 READ COMMITTED로 사용하되 트랜잭션 단위를 직접
하나의 비즈니스 로직이 처리될때 데이터 참조가 발생하는 의존된 메서드 단위로 묶어서 처리.
- Java 프로세스에서 스레드간 발생할 수 있는 자원동시참조 이슈 & 데이터 정합성 문제를 해결하기 위해 필요한 부분에만 **synchronized**를 사용하고 변수에는 Automic
- 
###**2) DB 접근에 대한 비용 & 부하 최소화 고려**
- RDB(MariaDB)에서 일어날 수 있는 많은 커넥션, 잦은 조회로 인한 성능저하 등의 이유로 인해 MariaDB의 특성과 Redis의 특성을 살려 중요하지 않지만 자주 Read 일 **동시성 이슈**를 해결하기 위해 **@Transactional** 을 사용하여 트랜잭션 격리 수준을 READ COMMITTED로 사용하되 트랜잭션 단위를 직접
  하나의 비즈니스 로직이 처리될때 데이터 참조가 발생하는 의존된 메서드 단위로 묶어서 처리.
- 
###**3) 카카오, 네이버 등 검색 API 제공자의 “다양한” 장애 발생 상황에 대한 고려**

- 추후 구현함.

###**4) 구글 장소 검색 등 새로운 검색 API 제공자의 추가 시 변경 영역 최소화에 대한 고려**
- 추후 확장성을 고려하여 각 API제공자의 인터페이스를 생성하고 타입별(카카오,네이버,구글 등)로 하나의 인터페이스 객체만 호출하여 기존에 쓰던 로직에 큰 영향이 가지않고 추가되더라도 유지보수에 편리함을 제공할 수 있도록
  제공자를 호출하는 로직을 정형화 시켜 구현함.

###**5) 서비스 오류 및 장애 처리 방법에 대한 고려**
- 추후 구현함.

###**6) 대용량 트래픽 처리를 위한 반응성(Low Latency), 확장성(Scalability), 가용성(Availability)을 높이기 위한 고려**
- 추후 구현함.

###**7) 지속적 유지 보수 및 확장에 용이한 아키텍처에 대한 설계**
- 추후 구현함.

###**8) 추후 공통작업을 고려한 설계**
- 추후 서비스 앞단에서 공통적으로 수행해야할 로직이 있다면 AOP 구현으로 세부적이고 간편하게 추가 기능개발 및 유지보수를 할 수 있도록 구현함.

###**9) 에러처리에 대한 설계**
- 각 컨트롤러에서 발생하는 에러들을 따로 공통 정의하여 에러를 상세 컨트롤 하게끔 설계함. 이로인해 각 서비스안에서 일어나는 try/catch로 Exception를 잡는등의
**불필요한 코드 생성 방지** 측이나 **유지보수 측면**에서도 유리할수있도록 설계 & 구현하였음.

###**10) 추가 설계 & 구현 포인트**
- DB는 총 각각 000,000,00 테이블로 나눠 설계했으며 log 테이블은 후에 사용자의 활동 추적을 위해 생성.
- 각 API의 단위 테스트는 기본 서비스 단위 테스트로 성공/실패 대표 케이스 기준으로 DB까지 잘 다녀오는지에 대해 작성.
- RESTFUL 방식의 URL 호출, 메소드에 따른 액션 정의 기준을 따라 개발하였음.
  
  


###[추가 설명]
1) 서비스 특정상 조회기능이 주된기능으로 공통된 조회건(예를들어 추천 검색 키워드 등)들은 DB에 부하를 분리하여 Redis에 1분 단위로 DB에서 조회하여 PUT하고
사용자(Client)들은 Redis에서 추천키워드를 읽어가도록 분리함. 이는 Redis특성상 추후 유동적인 요건에 유연하게 반응이 가능하고 DB에 불필요한 부하를 줄여주는 효과를 가진다.

* * *
####[첨부 파일 목록 및 설명]
1. resources/schema.sql : 테스트시 MariaDB에 넣을 기본 스키마 및 기초데이터 .sql 파일이다.
2. 개발간 사용한 mariadb, redis 도커 이미지 첨부.
3. Swagger 접속 정보
- http://localhost:9802/swagger-ui.html#

#### [부가 설명]
- Maria DB와 Redis는 구현 후 테스트간 직접 로컬PC에 Docker-container 형태로 기동하여 테스트 하였음.
- Redis-cli를 통해 Redis-server에 저장된 값을 확인하고 싶은 경우 첨부된 Redis-cli-README.md 참조.